"""
Mendeleev's nano-clusters
=========================

This example demonstrates how to stress test universal machine learning potentials
by simulating a complex nanoparticle containing a all the elements that are supported
by the target model. We will use the version 1.5.0 of the PET-MAD universal potential, 
which covers 102 elements, using ASE, and `i-PI <https://ipi-code.org>`_. 

Clusters are generated by randomly populating a FCC supercell with the supported elements, 
and then relaxed. These structures are then used as starting points for a Replica Exchange 
Molecular Dynamics (REMD) simulation, where we attempt both temperature swaps and Monte Carlo 
atomic swaps to explore the compositional and structural space of the cluster across a range 
of temperatures.
"""

# %%
# First, we import the required libraries.

import ase.io
import chemiscope
import matplotlib.pyplot as plt
import upet

# i-PI utilities
from ipi.utils.parsing import read_output, read_trajectory
from ipi.utils.scripting import InteractiveSimulation

# %%
# First, we download the universal potential model. We will use the extra-small (xs) 
# version of PET-MAD, version 1.5.0. 
# The `upet` package provides a handy utility to fetch models and save them locally.

model_path = "pet-mad-xs-v1.5.0.pt"
upet.save_upet(model="pet-mad", size="xs", version="1.5.0", output=model_path)

# %%
# Generating the clusters
# -----------------------
# We start by generating a collection of random atomic configurations. 
# The script `make_soup.py` creates FCC supercells, randomly populates them 
# with the chemical elements supported by the PET-MAD model, and relaxes them.
#
# We have configured `make_soup.py` as a command-line tool. You could invoke it 
# directly from the command line, passing the path to the model and the number 
# of clusters to generate.
#
# .. code-block:: bash
#
#    puthon data/make_soup.py --model pet-mad-xs-v1.5.0.pt --n_soup 16
#
# In this example, we will use the pre-generated `soup_relaxed-*.xyz` files in the
# `data` directory to save time, as geometry optimization of 16 dense 
# nanoparticles can take a while.
# We load these files, enlarge the simulation cell to 40x40x40 Ã…, and shift the 
# atoms to the center of the cell. The resulting files are saved in the root folder.

for i in range(16):
    atoms = ase.io.read(f"data/soup_relaxed-{i:02d}.xyz")
    atoms.set_cell([40.0, 40.0, 40.0])
    atoms.center()
    ase.io.write(f"nano_soup-{i:02d}.xyz", atoms)

# Let's load and visualize the starting configurations.

initial_structures = [ase.io.read(f"nano_soup-{i:02d}.xyz") for i in range(16)]
chemiscope.show(initial_structures, mode="structure", settings=chemiscope.quick_settings(
    trajectory=True,
    structure_settings={"unitCell": True, "bonds": False, "spaceFilling": True},
))

# %%
# Running Replica Exchange Molecular Dynamics
# -------------------------------------------
# We use `i-PI` to run a REMD simulation. The input file `input-remd.xml` 
# defines 16 replicas spanning a temperature range from 300 K to 3000 K.
# 
# A ``<smotion mode='remd'>`` block attempts exchanges between adjacent replicas.
# Furthermore, a ``<motion mode='atomswap'>`` block inside the standard MD 
# integrator allows Monte Carlo swapping of chemical identities during the dynamics.
#
# Let's inspect the `i-PI` input XML:

with open("data/input-remd.xml", "r") as f:
    xml_input = f.read()
    
# We will use ``InteractiveSimulation`` to run i-PI directly from this Python script.
#
# .. warning::
#     Running 16 replicas of a 108-atom system using a neural network potential 
#     is computationally intensive! Here we run only 10 steps for demonstration.
# In a real scenario, you would execute `i-pi data/input-remd.xml` via the command 
# line or a batch script.

# sim = InteractiveSimulation(xml_input)

# Run a very short simulation
# sim.run(100)

# %%
# Analyzing the Results
# ---------------------
# Once the simulation finishes, `i-PI` produces trajectory files and output 
# logs for each replica. 
#
# Let's load the trajectories and output data of all 16 replicas.

trajectories = []
data_list = []
for i in range(16):
    data, info = read_output(f"{i:02d}_soup-nano.out")
    trj = read_trajectory(f"{i:02d}_soup-nano.pos_0.extxyz", format="ase")
    trajectories.append(trj)
    data_list.append(data)

# %%
# We then assemble them into a single trajectory where the 16 clusters
# are offset to form a 4x4 grid. We will also use chemiscope's `shapes`
# feature to put transparent spheres around each cluster, colored 
# according to the temperature of the replica at that step.

import numpy as np
import matplotlib.cm as cm
import matplotlib.colors as mcolors

n_frames = min(len(t) for t in trajectories)
combined_trj = []
temperatures_over_time = {i: [] for i in range(16)}

# The trajectory stride is 10 and property stride is 2.
# Therefore, frame f corresponds to data index f * (10 // 2) = f * 5.
for f in range(n_frames):
    data_idx = f * 5
    if data_idx >= len(data_list[0]["step"]):
        data_idx = len(data_list[0]["step"]) - 1
        
    cell = [160.0, 160.0, 40.0]
    merged_atoms = ase.Atoms(cell=cell, pbc=True)
    
    for i in range(16):
        row = i // 4
        col = i % 4
        
        atoms = trajectories[i][f].copy()
        # Shift the atoms so they form a 4x4 grid.
        # Original cell is 40x40x40.
        shift = np.array([col * 40.0, row * 40.0, 0.0])
        atoms.positions += shift
        merged_atoms += atoms
        
        T = data_list[i]["ensemble_temperature"][data_idx]
        temperatures_over_time[i].append(T)

    combined_trj.append(merged_atoms)

# Create shapes for each cluster
shapes = {}
cmap = cm.get_cmap('coolwarm')
norm = mcolors.Normalize(vmin=300, vmax=3000)

for i in range(16):
    row = i // 4
    col = i % 4
    
    structure_params = []
    for f in range(n_frames):
        T = temperatures_over_time[i][f]
        # Get hex color and format it for chemiscope (e.g., 0xFF0000).
        # We append an alpha channel to make the spheres transparent.
        rgba = cmap(norm(T))
        hex_color = mcolors.to_hex(rgba, keep_alpha=True).upper().replace("#", "0x")
        
        # Center of the 40x40x40 box is at [20, 20, 20]
        structure_params.append({
            "position": [col * 40.0 + 20.0, row * 40.0 + 20.0, 20.0],
            "color": hex_color
        })
        
    shapes[f"cluster_{i}"] = {
        "kind": "sphere",
        "parameters": {
            "global": {"radius": 19.0},
            "structure": structure_params
        }
    }

# %%
# Finally, we can use `chemiscope` to visualize the combined trajectory.

chemiscope.show(
    structures=combined_trj,
    mode="structure",
    shapes=shapes,
    settings=chemiscope.quick_settings(
        structure_settings={
            "unitCell": True,
            "shape": list(shapes.keys())
        },
        trajectory=True,
    ),
)
