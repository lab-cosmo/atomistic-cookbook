
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/flashmd/flashmd-demo.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_flashmd_flashmd-demo.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_flashmd_flashmd-demo.py:


Long-stride trajectories with a universal FlashMD model
=======================================================

:Authors: Michele Ceriotti `@ceriottm <https://github.com/ceriottm>`_

For a quickstart on how to use FlashMD with ASE,
you can go `here <https://github.com/lab-cosmo/flashmd>`_.

This example demonstrates how to run long-stride molecular dynamics using the
universal FlashMD model. FlashMD predicts directly positions and momenta of atoms
at a later time based on the current positions and momenta.
It is trained to reproduce MD trajectories at the r2SCAN level of theory.
You can read more about the model and its limitations in
`this preprint <http://arxiv.org/abs/2505.19350>`_.

.. GENERATED FROM PYTHON SOURCE LINES 17-20

.. code-block:: Python


    # sphinx_gallery_thumbnail_path = '../../examples/flashmd/flashmd-scheme.png'








.. GENERATED FROM PYTHON SOURCE LINES 21-29

Start by importing the required libraries. You will need
`FlashMD <https://github.com/lab-cosmo/flashmd>`_
and a recent version of `i-PI <http://ipi-code.org>`_.

.. code-block:: bash

    pip install flashmd ipi


.. GENERATED FROM PYTHON SOURCE LINES 30-38

.. code-block:: Python


    import chemiscope
    from flashmd import get_pretrained
    from flashmd.ipi import get_npt_stepper, get_nvt_stepper
    from ipi.utils.parsing import read_output, read_trajectory
    from ipi.utils.scripting import InteractiveSimulation









.. GENERATED FROM PYTHON SOURCE LINES 39-46

A rough schematic of the architecture of FlashMD is shown below.
Each model is trained for a specific stride length, aiming to
reproduce the trajectories obtained with a traditional velocity
Verlet integrator.

.. image:: flashmd-scheme.png
   :align: center

.. GENERATED FROM PYTHON SOURCE LINES 49-52

We start by getting the FlashMD models from the ``flashmd`` package.
We will also use a PET model trained on the MATPES dataset as the accompanying energy
model

.. GENERATED FROM PYTHON SOURCE LINES 52-63

.. code-block:: Python


    device = "cpu"  # change to "cuda" if you have a GPU; don't forget to change it in the
    # i-PI xml input files as well!

    mlip_model, flashmd_model_16 = get_pretrained("pet-omatpes", 16)
    mlip_model, flashmd_model_64 = get_pretrained("pet-omatpes", 64)

    # We save the MLIP model to disk, since i-PI needs to read it from a file
    mlip_model.save("pet-omatpes.pt")









.. GENERATED FROM PYTHON SOURCE LINES 64-75

Al(110) surface dynamics
------------------------

The (110) surface of aluminum exhibits `an interesting dynamical behavior
<https://doi.org/10.1103/PhysRevLett.82.3296>`_ well below the bulk melting
temperature. This manifests itself in the spontaneous formation of surface
defects, with mobile adatoms emerging at the surface.

We run a FlashMD simulation with 64 fs strides (as opposed to 1 or 2 fs) at
600 K, observing the motion of the adatom at the surface. We use the
``i-PI`` scripting API to set up the simulation and run it interactively.

.. GENERATED FROM PYTHON SOURCE LINES 77-81

The starting point is a "base" XML file that contains the setup for a traditional
MD simulation in i-PI. It contains the MLIP as the potential energy calculator
(needed for the optional energy rescaling filter), and the only difference is
the use of a much larger large time step than conventional MD.

.. GENERATED FROM PYTHON SOURCE LINES 81-85

.. code-block:: Python


    with open("data/input-al110-base.xml", "r") as input_xml:
        sim = InteractiveSimulation(input_xml)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

     @system: Initializing system object 
     @simulation: Initializing simulation object 
    @ RANDOM SEED: The seed used in this calculation was 32123
     @init_file: Initializing from file data/al110.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/al110.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/al110.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/al110.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/al110.xyz. Dimension: length, units: automatic, cell_units: automatic
     @initializer: Resampling velocities at temperature 600.0 kelvin
     @system.bind: Binding the forces 




.. GENERATED FROM PYTHON SOURCE LINES 86-97

To run FlashMD, we set up a custom step, using the ``get_nvt_stepper``
utility function from the `flashmd.ipi` module. Note the filters
``rescale_energy=False`` and ``random_rotation=True``. You can turn the former on to
ensure that the total energy of the system is conserved, at the cost of one extra
energy evaluation per step, while the latter is inexpensive and allows for random
rotations of the system, which is useful to correct for the fact that the model is not
exactly equivariant with respect to rotations. Note that the ``xml`` input uses
the option ``non-conservative:True``: only the energy is needed to monitor and
correct for energy drift, and given that i-PI always evaluates also forces for good
measure, using a non-conservative model reduces the overead associated with the
potential energy evaluations that would occur when using ``rescale_energy=True``.

.. GENERATED FROM PYTHON SOURCE LINES 97-108

.. code-block:: Python


    sim.set_motion_step(
        get_nvt_stepper(
            sim, flashmd_model_64, device, rescale_energy=False, random_rotation=True
        )
    )

    # We run for 16 steps -- this is a large box, and it's rather slow on CPU...
    # ...but it's equivalent to more than 1 ps with FlashMD's 64 fs time steps!
    sim.run(16)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

     @simulation.run: Average timings at MD step       0. t/step: 7.70142e+00




.. GENERATED FROM PYTHON SOURCE LINES 109-112

The trajectory is stable, and one can check that the mean fluctuations
of the adatom are qualitatively correct, by comparing with a (much slower)
MLIP simulation.

.. GENERATED FROM PYTHON SOURCE LINES 112-136

.. code-block:: Python


    data, info = read_output("al110-nvt-flashmd.out")
    trj = read_trajectory("al110-nvt-flashmd.pos_0.extxyz")

    chemiscope.show(
        structures=trj,
        properties={
            "time": data["time"],
            "potential": data["potential"],
            "temperature": data["temperature"],
        },
        mode="default",
        settings=chemiscope.quick_settings(
            map_settings={
                "x": {"property": "time", "scale": "linear"},
                "y": {"property": "potential", "scale": "linear"},
            },
            structure_settings={
                "unitCell": True,
            },
            trajectory=True,
        ),
    )



.. chemiscope:: _datasets/fig_flashmd-demo_001.json.gz
            :mode: default
            :warning_timeout: 2000
        


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 137-155

Solvated alanine dipeptide
--------------------------

As a second example, we run a constant-pressure simulation of explicitly
solvated alanine dipeptide, using the FlashMD universal model with 16 fs
time steps (note that normal MD would require 0.5 fs steps). The setup
is very similar to the previous example, but we use an input template
that contains a NpT setup, and we use the ``get_npt_stepper`` utility
function to set up a stepper that combines the FlashMD velocity-Verlet
step with cell updates.

Note that the MLIP is now also used to
obtain stresses by backpropagation (and not only energies to enforce
energy conservation). Therefore, compared to the NVT run, we disable
non-conservative mode for the MLIP in the xml file. As long as the cell
degrees of freedom are thermostatted, like in this case, disabling
non-conservative mode wouldn't strictly be necessary to obtain a stable
run.

.. GENERATED FROM PYTHON SOURCE LINES 155-168

.. code-block:: Python


    with open("data/input-ala2-base.xml", "r") as input_xml:
        sim = InteractiveSimulation(input_xml)

    sim.set_motion_step(
        get_npt_stepper(
            sim, flashmd_model_16, device, rescale_energy=True, random_rotation=True
        )
    )

    # only run 2 steps: as for all modern MLIPs, serious simulations require a GPU
    sim.run(2)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

     @system: Initializing system object 
     @simulation: Initializing simulation object 
    @ RANDOM SEED: The seed used in this calculation was 32123
     @init_file: Initializing from file data/ala2.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/ala2.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/ala2.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/ala2.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/ala2.xyz. Dimension: length, units: automatic, cell_units: automatic
     @initializer: Resampling velocities at temperature 450.0 kelvin
     @system.bind: Binding the forces 
     @simulation.run: Average timings at MD step       0. t/step: 5.86289e+01
     @open_backup: Backup performed: RESTART -> #RESTART#0#




.. GENERATED FROM PYTHON SOURCE LINES 169-173

The cell fluctuates around the equilibrium volume, in a way that
is consistent with the correct NpT ensemble. The trajectory is stable
and the alanine molecule explores the different conformations
(obviously when running for a reasonably long time).

.. GENERATED FROM PYTHON SOURCE LINES 173-198

.. code-block:: Python


    data, info = read_output("ala2-npt-flashmd.out")
    trj = read_trajectory("ala2-npt-flashmd.pos_0.extxyz")

    chemiscope.show(
        structures=trj,
        properties={
            "time": data["time"],
            "volume": data["volume"],
            "potential": data["potential"],
            "pressure": data["pressure_md"],
            "temperature": data["temperature"],
        },
        mode="default",
        settings=chemiscope.quick_settings(
            map_settings={
                "x": {"property": "time", "scale": "linear"},
                "y": {"property": "volume", "scale": "linear"},
            },
            structure_settings={
                "unitCell": True,
            },
            trajectory=True,
        ),
    )


.. chemiscope:: _datasets/fig_flashmd-demo_002.json.gz
            :mode: default
            :warning_timeout: 2000
        


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">

    </div>
    <br />
    <br />


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (5 minutes 11.214 seconds)


.. _sphx_glr_download_examples_flashmd_flashmd-demo.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: flashmd-demo.ipynb <flashmd-demo.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: flashmd-demo.py <flashmd-demo.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

        :download:`Download recipe: flashmd-demo.zip <flashmd-demo.zip>`
    

.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
