
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/lode-linear/lode-linear.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_lode-linear_lode-linear.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_lode-linear_lode-linear.py:


Long-distance Equivariants: a tutorial
======================================

:Authors: Philip Loche `@PicoCentauri <https://github.com/PicoCentauri/>`_,
          Kevin Huguenin-Dumittan `@kvhuguenin <https://github.com/kvhuguenin>`_

This tutorial explains how Long range equivariant descriptors can be constructed using
featomic and the resulting descriptors be used to construct a linear model with
equisolve

First, import all the necessary packages

.. GENERATED FROM PYTHON SOURCE LINES 16-27

.. code-block:: Python


    import ase.io
    import matplotlib.pyplot as plt
    import metatensor
    import numpy as np
    from equisolve.numpy.models.linear_model import Ridge
    from equisolve.utils.convert import ase_to_tensormap
    from featomic import AtomicComposition, LodeSphericalExpansion, SphericalExpansion
    from featomic.clebsch_gordan import PowerSpectrum









.. GENERATED FROM PYTHON SOURCE LINES 28-43

Step 0: Prepare Data Set
------------------------

Get structures
~~~~~~~~~~~~~~

We take a small subset of the dimer dataset from `A. Grisafi et al.,
2021 <https://pubs.rsc.org/en/content/articlelanding/2021/sc/d0sc04934d>`_
for which we additionally calculated the forces. Each structure in the
dataset contains two small organic molecules which are extended along a
certain direction in the subsequent structures.

For speeding up the calculations we already selected the first 130
:download:`structures <charge-charge.xyz>` of the charge-charge molecule
pairs.

.. GENERATED FROM PYTHON SOURCE LINES 44-47

.. code-block:: Python


    frames = ase.io.read("charge-charge.xyz", ":")








.. GENERATED FROM PYTHON SOURCE LINES 48-55

Convert target properties to metatensor format
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If we want to train models using the
`equisolve <https://github.com/lab-cosmo/equisolve>`_ package, we need to
convert the target properties (in this case, the energies and forces)
into the appropriate format #justequistorethings

.. GENERATED FROM PYTHON SOURCE LINES 56-59

.. code-block:: Python


    y = ase_to_tensormap(frames, energy="energy", forces="forces")








.. GENERATED FROM PYTHON SOURCE LINES 60-61

rename to match new label conventions

.. GENERATED FROM PYTHON SOURCE LINES 61-80

.. code-block:: Python

    yg = y.block(0).gradient("positions")
    yb = metatensor.TensorBlock(
        y.block(0).values,
        y.block(0).samples.rename("structure", "system"),
        y.block(0).components,
        y.block(0).properties,
    )
    yb.add_gradient(
        "positions",
        metatensor.TensorBlock(
            yg.values,
            yg.samples.rename("structure", "system"),
            [yg.components[0].rename("direction", "xyz")],
            yg.properties,
        ),
    )
    y = metatensor.TensorMap(y.keys, [yb])









.. GENERATED FROM PYTHON SOURCE LINES 81-92

Step 1: Compute short-range and LODE features
---------------------------------------------

Define hypers and get the expansion coefficients :math:`\langle anlm | \rho_i \rangle`
and :math:`\langle anlm | V_i \rangle`

The short-range and long-range descriptors have very similar hyperparameters. We
highlight the differences below.

We first define the hyperparameters for the short-range (SR) part. These will be used
to create SOAP features.

.. GENERATED FROM PYTHON SOURCE LINES 93-105

.. code-block:: Python


    SR_HYPERS = {
        "cutoff": {"radius": 3.0, "smoothing": {"type": "ShiftedCosine", "width": 0.5}},
        "density": {"type": "Gaussian", "width": 0.3},
        "basis": {
            "type": "TensorProduct",
            "max_angular": 2,
            "radial": {"type": "Gto", "max_radial": 5},
        },
    }









.. GENERATED FROM PYTHON SOURCE LINES 106-107

And next the hyperparaters for the LODE / long-range (LR) part

.. GENERATED FROM PYTHON SOURCE LINES 108-119

.. code-block:: Python



    LR_HYPERS = {
        "density": {"type": "SmearedPowerLaw", "smearing": 3.0, "exponent": 1},
        "basis": {
            "type": "TensorProduct",
            "max_angular": 2,
            "radial": {"type": "Gto", "max_radial": 2, "radius": 2.0},
        },
    }








.. GENERATED FROM PYTHON SOURCE LINES 120-122

We then use the above defined hyperparaters to define the per atom short range (sr)
and long range (sr) descriptors.

.. GENERATED FROM PYTHON SOURCE LINES 122-127

.. code-block:: Python


    calculator_sr = SphericalExpansion(**SR_HYPERS)
    calculator_lr = LodeSphericalExpansion(**LR_HYPERS)









.. GENERATED FROM PYTHON SOURCE LINES 128-148

Note that LODE requires periodic systems. Therefore, if the data set does not come
with periodic boundary conditions by default you can not use the data set and you will
face an error if you try to compute the features.

As you notices the calculation of the long range features takes significant more time
compared to the sr features.

Taking a look at the output we find that the resulting
:py:class:`metatensor.TensorMap` are quite similar in their structure. The short range
:py:class:`metatensor.TensorMap` contains more blocks due to the higher
``max_angular`` parameter we chose above.

Generate the rotational invariants (power spectra)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Rotationally invariant features can be obtained by taking two of the calculators that
were defines above.

For the short-range part, we use the SOAP vector which is obtained by computing the
invariant combinations of the form :math:`\rho \otimes \rho`.

.. GENERATED FROM PYTHON SOURCE LINES 149-154

.. code-block:: Python


    ps_calculator_sr = PowerSpectrum(calculator_sr, calculator_sr)
    ps_sr = ps_calculator_sr.compute(frames, gradients=["positions"])









.. GENERATED FROM PYTHON SOURCE LINES 155-161

We calculate gradients with respect to pistions by providing the
``gradients=["positions"]`` option to the
:py:meth:`featomic.calculators.CalculatorBase.compute()` method.

For the long-range part, we combine the long-range descriptor :math:`V` with one a
short-range density :math:`\rho` to get :math:`\rho \otimes V` features.

.. GENERATED FROM PYTHON SOURCE LINES 162-167

.. code-block:: Python


    ps_calculator_lr = PowerSpectrum(calculator_sr, calculator_lr)
    ps_lr = ps_calculator_lr.compute(systems=frames, gradients=["positions"])









.. GENERATED FROM PYTHON SOURCE LINES 168-177

Step 2: Building a Simple Linear SR + LR Model with energy baselining
---------------------------------------------------------------------

Preprocessing (model dependent)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For our current model, we do not wish to treat the individual center and
neighbor species separately. Thus, we move the ``"center_type"`` key
into the ``atom`` dimension, over which we will later sum over.

.. GENERATED FROM PYTHON SOURCE LINES 178-183

.. code-block:: Python


    ps_sr = ps_sr.keys_to_samples("center_type")
    ps_lr = ps_lr.keys_to_samples("center_type")









.. GENERATED FROM PYTHON SOURCE LINES 184-186

For linear models only: Sum features up over atoms in the same
structure.

.. GENERATED FROM PYTHON SOURCE LINES 187-194

.. code-block:: Python


    sample_names_to_sum = ["atom", "center_type"]

    ps_sr = metatensor.sum_over_samples(ps_sr, sample_names=sample_names_to_sum)
    ps_lr = metatensor.sum_over_samples(ps_lr, sample_names=sample_names_to_sum)









.. GENERATED FROM PYTHON SOURCE LINES 195-201

Initialize tensormaps for energy baselining
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We add a simple extra descriptor :py:class:`featomic.AtomicComposition` that stores
how many atoms of each chemical species are contained in the structures. This is used
for energy baselining.

.. GENERATED FROM PYTHON SOURCE LINES 202-209

.. code-block:: Python


    calculator_co = AtomicComposition(per_system=False)
    descriptor_co = calculator_co.compute(frames, gradients=["positions"])

    co = descriptor_co.keys_to_properties(["center_type"])
    co = metatensor.sum_over_samples(co, sample_names=["atom"])








.. GENERATED FROM PYTHON SOURCE LINES 210-231

The :py:class:`featomic.AtomicComposition` calculator also allows to directly perform
the the sum over center atoms by using the following lines.

.. code:: python

   descriptor_co = AtomicComposition(per_structure=True).compute(**compute_args)
   co = descriptor_co.keys_to_properties(["center_type"])

Stack all the features together for linear model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A linear model on SR + LR features can be thought of as a linear model
built on a feature vector that is simply the concatenation of the SR and
LR features.

Furthermore, energy baselining can be performed by concatenating the information about
chemical species as well. There is an metatensor function called
:py:func:`metatensor.join()` for this purpose. Formally, we can write for the SR
model.

X_sr: :math:`1 \oplus \left(\rho \otimes \rho\right)`

.. GENERATED FROM PYTHON SOURCE LINES 232-236

.. code-block:: Python


    X_sr = metatensor.join([co, ps_sr], axis="properties")









.. GENERATED FROM PYTHON SOURCE LINES 237-244

We used the ``axis="properties"`` parameter since we want to concatenate along the
features/properties dimensions.

For the long range model we can formerly write

X_lr: :math:`1 \oplus \left(\rho \otimes \rho\right) \oplus \left(\rho \otimes
V\right)`

.. GENERATED FROM PYTHON SOURCE LINES 245-249

.. code-block:: Python


    X_lr = metatensor.join([co, ps_sr, ps_lr], axis="properties")









.. GENERATED FROM PYTHON SOURCE LINES 250-257

The features are now ready! Let us now perform some actual learning. Below we
initialize two instances of the :py:class:`equisolve.numpy.models.linear_model.Ridge`
class. :py:class:`equisolve.numpy.models.linear_model.Ridge` will perform a regression
with respect to ``"values"`` (energies) and ``"positions"`` gradients (forces).

If you only want a fit with respect to energies you can remove the gradients with
``metatensor.remove_gradients()``

.. GENERATED FROM PYTHON SOURCE LINES 258-263

.. code-block:: Python


    clf_sr = Ridge()
    clf_lr = Ridge()









.. GENERATED FROM PYTHON SOURCE LINES 264-270

Split training and target data into train and test dat
------------------------------------------------------

Split the training and the test data by the distance :math:`r_{\rm
train}=6\,\mathrm{Å}` between the center of mass of the two molecules. A structure
with a :math:`r_{\rm train}<6 {\rm Å}` is used for training.

.. GENERATED FROM PYTHON SOURCE LINES 271-275

.. code-block:: Python


    r_cut = 6.0









.. GENERATED FROM PYTHON SOURCE LINES 276-278

We calculate the indices from the dataset by list comprehension. The center of mass
distance is stored in the ``"distance""`` attribute.

.. GENERATED FROM PYTHON SOURCE LINES 279-284

.. code-block:: Python


    idx_train = [i for i, f in enumerate(frames) if f.info["distance"] < r_cut]
    idx_test = [i for i, f in enumerate(frames) if f.info["distance"] >= r_cut]









.. GENERATED FROM PYTHON SOURCE LINES 285-287

For doing the split we define two ``Labels`` instances and combine them in a
:py:class:`List`.

.. GENERATED FROM PYTHON SOURCE LINES 288-293

.. code-block:: Python


    samples_train = metatensor.Labels(["system"], np.reshape(idx_train, (-1, 1)))
    samples_test = metatensor.Labels(["system"], np.reshape(idx_test, (-1, 1)))
    grouped_labels = [samples_train, samples_test]








.. GENERATED FROM PYTHON SOURCE LINES 294-295

That we use as input to the :py:func:`metatensor.split()` function

.. GENERATED FROM PYTHON SOURCE LINES 296-308

.. code-block:: Python


    X_sr_train, X_sr_test = metatensor.split(
        X_sr, axis="samples", selections=grouped_labels
    )

    X_lr_train, X_lr_test = metatensor.split(
        X_lr, axis="samples", selections=grouped_labels
    )

    y_train, y_test = metatensor.split(y, axis="samples", selections=grouped_labels)









.. GENERATED FROM PYTHON SOURCE LINES 309-316

Fit the model
-------------

For this model, we use a very simple regularization scheme where all features are
regularized in the same way (the amount being controlled by the parameter ``alpha``).
For more advanced regularization schemes (regularizing energies and forces differently
and/or the SR and LR parts differently), see further down.

.. GENERATED FROM PYTHON SOURCE LINES 317-322

.. code-block:: Python


    clf_sr.fit(X_sr_train, y_train, alpha=1e-6)
    clf_lr.fit(X_lr_train, y_train, alpha=1e-6)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <equisolve.numpy.models.linear_model.NumpyRidge object at 0x7f0541567790>



.. GENERATED FROM PYTHON SOURCE LINES 323-328

Evaluation
----------

For evaluating the model we calculate the RMSEs using the ``score()`` method. With the
``parameter_key`` parameter we select which RMSE should be calculated.

.. GENERATED FROM PYTHON SOURCE LINES 329-349

.. code-block:: Python


    print(
        "SR: RMSE energies = "
        f"{clf_sr.score(X_sr_test, y_test, parameter_key='values')[0]:.3f} eV"
    )
    print(
        "SR: RMSE forces = "
        f"{clf_sr.score(X_sr_test, y_test, parameter_key='positions')[0]:.3f} eV/Å"
    )

    print(
        "LR: RMSE energies = "
        f"{clf_lr.score(X_lr_test, y_test, parameter_key='values')[0]:.3f} eV"
    )
    print(
        "LR: RMSE forces = "
        f"{clf_lr.score(X_lr_test, y_test, parameter_key='positions')[0]:.3f} eV/Å"
    )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    SR: RMSE energies = 0.557 eV
    SR: RMSE forces = 0.188 eV/Å
    LR: RMSE energies = 0.272 eV
    LR: RMSE forces = 0.155 eV/Å




.. GENERATED FROM PYTHON SOURCE LINES 350-356

We find that the RMSE of the energy and the force of the LR model is smaller compared
to the SR model. From this we conclude that the LR model performs better for the
selection of the dataset.

We additionally, can plot of the binding energy as a function of the distance. For the
plot we select some properties from the dataset

.. GENERATED FROM PYTHON SOURCE LINES 357-363

.. code-block:: Python


    dist = np.array([f.info["distance"] for f in frames])
    energies = np.array([f.info["energy"] for f in frames])
    monomer_energies = np.array([f.info["energyA"] + f.info["energyB"] for f in frames])









.. GENERATED FROM PYTHON SOURCE LINES 364-365

and select only the indices corresponding to our test set.

.. GENERATED FROM PYTHON SOURCE LINES 369-370

Next we calculate the predicted SR and LR ``TensorMaps``.

.. GENERATED FROM PYTHON SOURCE LINES 371-376

.. code-block:: Python


    y_sr_pred = clf_sr.predict(X_sr)
    y_lr_pred = clf_lr.predict(X_lr)









.. GENERATED FROM PYTHON SOURCE LINES 377-378

And, finally perform the plot.

.. GENERATED FROM PYTHON SOURCE LINES 379-408

.. code-block:: Python


    plt.scatter(
        dist, y.block().values[:, 0] - monomer_energies, label="target data", color="black"
    )

    plt.scatter(
        dist,
        y_sr_pred.block().values[:, 0] - monomer_energies,
        label="short range model",
        marker="x",
    )

    plt.scatter(
        dist,
        y_lr_pred.block().values[:, 0] - monomer_energies,
        label="long range model",
        marker="s",
        facecolor="None",
        edgecolor="orange",
    )

    plt.xlabel("center of mass distance in Å")
    plt.ylabel(r"$E - E_\mathrm{monomer}$ in eV")
    plt.axvline(r_cut, c="red", label=r"$r_\mathrm{train}$")

    plt.legend()
    plt.tight_layout()
    plt.show()




.. image-sg:: /examples/lode-linear/images/sphx_glr_lode-linear_001.png
   :alt: lode linear
   :srcset: /examples/lode-linear/images/sphx_glr_lode-linear_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 10.011 seconds)


.. _sphx_glr_download_examples_lode-linear_lode-linear.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: lode-linear.ipynb <lode-linear.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: lode-linear.py <lode-linear.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

        :download:`Download recipe: lode-linear.zip <lode-linear.zip>`
    

.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
