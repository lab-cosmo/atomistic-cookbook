
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/thermostats/thermostats.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_thermostats_thermostats.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_thermostats_thermostats.py:


Constant-temperature MD and thermostats
=======================================

:Authors: Michele Ceriotti `@ceriottm <https://github.com/ceriottm/>`_

This recipe gives a practical introduction to finite-temperature
molecular dynamics simulations, and provides a guide to choose the
most appropriate thermostat for the simulation at hand.

As for other examples in the cookbook, a small simulation of liquid
water is used as an archetypal example. Molecular dynamics, sampling,
and constant-temperature simulations are discussed in much detail in
the book "Understanding Molecular Simulations" by Daan Frenkel and Berend Smit.
This
`seminal paper by H.C.Andersen <https://doi.org/10.1063/1.439486>`_
provides a good historical introduction to the problem of
thermostatting, and this
`PhD thesis
<https://www.research-collection.ethz.ch/handle/20.500.11850/152344>`_
provides a more detailed background to several of the techniques
discussed in this recipe.

.. GENERATED FROM PYTHON SOURCE LINES 24-27

.. code-block:: Python


    import os








.. GENERATED FROM PYTHON SOURCE LINES 28-41

.. code-block:: Python

    import subprocess
    import time
    import xml.etree.ElementTree as ET

    import chemiscope
    import ipi
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    import numpy as np
    from ipi.utils.tools.acf_xyz import compute_acf_xyz
    from ipi.utils.tools.gle import get_gle_matrices, gle_frequency_kernel, isra_deconvolute









.. GENERATED FROM PYTHON SOURCE LINES 42-67

Constant-temperature sampling of (thermo)dynamics
-------------------------------------------------

Even though Hamilton's equations in classical mechanics conserve the total
energy of the group of atoms in a simulation, experimental boundary conditions
usually involve exchange of heat with the surroundings, especially when considering
the relatively small supercells that are often used in simulations.

The goal of a constant-temperature MD simulation is to compute efficiently thermal
averages of the form :math:`\langle A(q,p)\rangle_\beta`, where the average
of the observable :math:`A(q,p)` is
evaluated over the Boltzmann distribution at inverse temperature
:math:`\beta=1/k_\mathrm{B}T`,
:math:`P(q,p)=Q^{-1} \exp(-\beta(p^2/2m + V(q)))`
In all these scenarios, optimizing the simulation involves reducing as much as
possible the *autocorrelation time* of the observable.

Constant-temperature sampling is also important when one wants to compute
*dynamical* properties. In principle these would require
constant-energy trajectories, as any thermostatting procedure modifies
the dynamics of the system. However, the initial conditions
should usually be determined from constant-temperature conditions,
averaging over multiple constant-energy trajectories.
As we shall see, this protocol can often be simplified greatly, by choosing
thermostats that don't interfere with the natural microscopic dynamics.

.. GENERATED FROM PYTHON SOURCE LINES 69-87

Running simulations
~~~~~~~~~~~~~~~~~~~

We use `i-PI <http://ipi-code.org>`_ together with a ``LAMMPS`` driver to run
all the simulations in this recipe. The two codes need to be run separately,
and communicate atomic positions, energy and forces through a socket interface.

The LAMMPS input defines the parameters of the
`q-TIP4P/f water model <http://doi.org/10.1063/1.3167790>`_,
while the XML-formatted input of i-PI describes the setup of the
MD simulation.

We begin running a constant-energy calculation, that
we will use to illustrate the metrics that can be applied to
assess the performance of a thermostatting scheme. If it is the
first time you see an ``i-PI`` input, you may want to look at
the input file side-by-sidewith the
`input reference <https://docs.ipi-code.org/input-tags.html>`_.

.. GENERATED FROM PYTHON SOURCE LINES 87-93

.. code-block:: Python


    # Open and read the XML file
    with open("data/input_nve.xml", "r") as file:
        xml_content = file.read()
    print(xml_content)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <simulation verbosity='medium' safe_stride='100'>
      <output prefix='simulation_nve'>
          <properties stride='1' filename='out'>  
          [ step, time{picosecond}, conserved{electronvolt}, 
          temperature{kelvin}, kinetic_md{electronvolt}, potential{electronvolt}, 
          temperature(H){kelvin}, temperature(O){kelvin} ] </properties>
        <trajectory filename='pos' stride='10'> positions </trajectory>
        <trajectory filename='vel' stride='1'> velocities </trajectory>
      </output>
      <total_steps> 2000 </total_steps>
      <prng>
        <seed> 32342 </seed>
      </prng>
      <ffsocket name='lmpserial' mode='unix' pbc='false'>
          <address>h2o-lammps</address> <latency> 1e-4 </latency>
      </ffsocket>
      <system>
        <initialize nbeads='1'>
          <file mode='pdb' units='angstrom'> data/water_32.pdb </file>
          <velocities mode='thermal' units='kelvin'> 300 </velocities>
        </initialize>
        <forces>
          <force forcefield='lmpserial'> lmpserial </force>
        </forces>
        <ensemble>
          <temperature units='kelvin'>300</temperature>
        </ensemble>
        <motion mode='dynamics'>
          <dynamics mode='nve'>
            <timestep units='femtosecond'> 1.0 </timestep>
          </dynamics>
        </motion>
      </system>
    </simulation>





.. GENERATED FROM PYTHON SOURCE LINES 94-97

The part of the input that describes the molecular dynamics integrator
is the ``motion`` class. For this run, it specifies an *NVE* ensemble, and
a ``timestep`` of 1 fs for the integrator.

.. GENERATED FROM PYTHON SOURCE LINES 97-101

.. code-block:: Python


    xmlroot = ET.parse("data/input_nve.xml").getroot()
    print("    " + ET.tostring(xmlroot.find(".//motion"), encoding="unicode"))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

        <motion mode="dynamics">
          <dynamics mode="nve">
            <timestep units="femtosecond"> 1.0 </timestep>
          </dynamics>
        </motion>
  




.. GENERATED FROM PYTHON SOURCE LINES 102-108

Note that this -- and other runs in this example -- are too short to
provide quantitative results, and you may want to increase the
``<total_steps>`` parameter so that the simulation runs for at least
a few tens of ps. The time step of 1 fs is also at the limit of what
is acceptable for running simulations of water. 0.5 fs would be a
safer, stabler value.

.. GENERATED FROM PYTHON SOURCE LINES 111-122

To launch i-PI and LAMMPS from the command line you can just
execute the following commands

.. code-block:: bash

   i-pi data/input_nve.xml > log &
   sleep 2
   lmp -in data/in.lmp &

To launch the external processes from a Python script
proceed as follows:

.. GENERATED FROM PYTHON SOURCE LINES 122-129

.. code-block:: Python


    ipi_process = None
    if not os.path.exists("simulation_nve.out"):
        ipi_process = subprocess.Popen(["i-pi", "data/input_nve.xml"])
        time.sleep(4)  # wait for i-PI to start
        lmp_process = [subprocess.Popen(["lmp", "-in", "data/in.lmp"]) for i in range(1)]








.. GENERATED FROM PYTHON SOURCE LINES 130-133

If you run this in a notebook, you can go ahead and start loading
output files *before* i-PI and LAMMPS have finished running, by
skipping this cell

.. GENERATED FROM PYTHON SOURCE LINES 133-139

.. code-block:: Python


    if ipi_process is not None:
        ipi_process.wait()
        lmp_process[0].wait()









.. GENERATED FROM PYTHON SOURCE LINES 140-146

Analyzing the simulation
~~~~~~~~~~~~~~~~~~~~~~~~

After the simulation is finished, we can look at the outputs.
The outputs include the trajectory of positions, the velocities
and a number of energetic observables

.. GENERATED FROM PYTHON SOURCE LINES 146-150

.. code-block:: Python


    output_data, output_desc = ipi.read_output("simulation_nve.out")
    traj_data = ipi.read_trajectory("simulation_nve.pos_0.xyz")








.. GENERATED FROM PYTHON SOURCE LINES 151-154

The trajectory shows mostly local vibrations on this short time scale,
but if you re-run with a longer ``<total_steps>`` settings you should be
able to observe diffusing molecules in the liquid.

.. GENERATED FROM PYTHON SOURCE LINES 154-163

.. code-block:: Python


    chemiscope.show(
        traj_data,
        mode="structure",
        settings=chemiscope.quick_settings(
            trajectory=True, structure_settings={"unitCell": True}
        ),
    )



.. chemiscope:: _datasets/fig_thermostats_001.json.gz
            :mode: structure
            :warning_timeout: 2000
        


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 164-170

Potential and kinetic energy fluctuate, but the total energy is
(almost) constant, the small fluctuations being due to integration
errors, that are quite large with the long time step used for this
example. If you run with smaller ``<timestep>`` values, you should
see that the energy conservation condition is fulfilled with higher
accuracy.

.. GENERATED FROM PYTHON SOURCE LINES 170-195

.. code-block:: Python


    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.plot(
        output_data["time"],
        output_data["potential"] - output_data["potential"][0],
        "b-",
        label="Potential, $V$",
    )
    ax.plot(
        output_data["time"],
        output_data["kinetic_md"],
        "r-",
        label="Kinetic, $K$",
    )
    ax.plot(
        output_data["time"],
        output_data["conserved"] - output_data["conserved"][0],
        "k-",
        label="Conserved, $H$",
    )
    ax.set_xlabel(r"$t$ / ps")
    ax.set_ylabel(r"energy / eV")
    ax.legend()
    plt.show()




.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_001.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 196-209

In a classical MD simulation, based on the momentum :math:`\mathbf{p}`
of each atom, it is possible to evaluate its *kinetic temperature
estimator* :math:`T=\langle \mathbf{p}^2/m \rangle /3k_B` the average is to
be intended over a converged trajectory. Keep in mind that

1. The *instantaneous* value of this estimator is meaningless
2. It is only well-defined in a constant-temperature simulation, so here
   it only gives a sense of whether atomic momenta are close to what one
   would expect at 300 K.

With these caveats in mind, we can observe that the simulation has higher
velocities than expected at 300 K, and that there is no equipartition, the
O atoms having on average a higher energy than the H atoms.

.. GENERATED FROM PYTHON SOURCE LINES 209-229

.. code-block:: Python


    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.plot(
        output_data["time"],
        output_data["temperature(O)"],
        "r-",
        label="O atoms",
    )
    ax.plot(
        output_data["time"],
        output_data["temperature(H)"],
        "c-",
        label="H atoms",
    )
    ax.plot(output_data["time"], output_data["temperature"], "k-", label="All atoms")
    ax.set_xlabel(r"$t$ / ps")
    ax.set_ylabel(r"$\tilde{T}$ / K")
    ax.legend()
    plt.show()




.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_002.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 230-239

In order to investigate the dynamics more carefully, we
compute the velocity-velocity autocorrelation function
:math:`c_{vv}(t)=\sum_i \langle \mathbf{v}_i(t) \cdot \mathbf{v}_i(0) \rangle`.
We use a utility function that reads the outputs of ``i-PI``
and computes both the autocorrelation function and its Fourier
transform.
:math:`c_{vv}(t)` contains information on the time scale and amplitude
of molecular motion, and is closely related to the vibrational density
of states and to spectroscopic observables such as IR and Raman spectra.

.. GENERATED FROM PYTHON SOURCE LINES 239-260

.. code-block:: Python


    acf_nve = compute_acf_xyz(
        "simulation_nve.vel_0.xyz",
        maximum_lag=600,
        length_zeropadding=2000,
        spectral_windowing="cosine-blackman",
        timestep=1,
        time_units="femtosecond",
        skip=100,
    )

    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.plot(
        acf_nve[0][:1200] * 2.4188843e-05,  # atomic time to ps
        acf_nve[1][:1200] * 1e5,
        "r-",
    )
    ax.set_xlabel(r"$t$ / ps$")
    ax.set_ylabel(r"$c_{vv}$ / arb. units")
    plt.show()




.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_003.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 261-271

The power spectrum (that can be computed as the Fourier transform of
:math:`c_{vv}`) reveals the frequencies of stretching, bending and libration
modes of water; the :math:`\omega\rightarrow 0` limit is proportional
to the diffusion coefficient.
We also load the results from a reference calculation (average of 8
trajectories initiated from NVT-equilibrated samples, shown as the
confidence interval). You can see how to run these reference calculations
from the script ``data/run_traj.sh``.
The differences are due to the short trajectory, and to the fact that the
NVE trajectory is not equilibrated at 300 K.

.. GENERATED FROM PYTHON SOURCE LINES 271-293

.. code-block:: Python


    ha2cm1 = 219474.63

    # Loads reference trajectory
    acf_ref = np.loadtxt("data/traj-all_facf.data")

    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)

    ax.fill_between(
        acf_ref[:1200, 0] * ha2cm1,
        (acf_ref[:1200, 1] - acf_ref[:1200, 2]) * 1e5,
        (acf_ref[:1200, 1] + acf_ref[:1200, 2]) * 1e5,
        color="gray",
        label="reference",
    )

    ax.loglog(acf_nve[3][:1200] * ha2cm1, acf_nve[4][:1200] * 1e5, "r-", label="NVE")
    ax.set_xlabel(r"$\omega$ / cm$^{-1}$")
    ax.set_ylabel(r"$\hat{c}_{vv}$ / arb. units")
    ax.legend()
    plt.show()




.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_004.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 294-329

Langevin thermostatting
-----------------------

In order to perform a simulations that samples configurations
consistent with a Boltzmann distribution :math:`e^{-V(x)/k_B T}`
one needs to modify the equations of motion. There are many
different approaches to do this, some of which lead to deterministic
dynamics; the two more widely used deterministic thermostats
are the
`Berendsen thermostat <https://doi.org/10.1063/1.448118>`_
which does not sample the Boltzmann distribution exactly and
should never be used given the many more rigorous alternatives,
and the Nosé-Hoover thermostat, that requires a
`"chain" implementation <https://doi.org/10.1063/1.463940>`_
to be ergodic, which amounts essentially to a complicated way
to generate poor-quality pseudo-random numbers.

Given the limitations of deterministic thermostats, in this
recipe we focus on stochastic thermostats, that model the
coupling to the chaotic dynamics of an external bath through
explicit random numbers. Langevin dynamics amounts to adding
to Hamilton's equations of motion, for each degree of freedom,
a term of the form

.. math::

   \dot{p} =  -\gamma p + \sqrt{2\gamma m k_B T} \, \xi(t)

where :math:`
\gamma` is a friction coefficient, and :math:`\xi`
uncorrelated random numbers that mimic collisions with the bath
particles. The friction can be seen as the inverse of a
characteristic *coupling time scale*
:math:`\tau=1/\gamma` that describes how strongly the bath
interacts with the system.

.. GENERATED FROM PYTHON SOURCE LINES 331-339

Setting up a thermostat in ``i-PI``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to set up a thermostat in ``i-PI``, one simply needs
to adjust the ``<dynamics>`` block, to perform ``nvt`` dynamics
and include an appropriate ``<thermostat>`` section.
Here we use a very-strongly coupled Langevin thermostat,
with :math:`\tau=10~fs`.

.. GENERATED FROM PYTHON SOURCE LINES 339-343

.. code-block:: Python


    xmlroot = ET.parse("data/input_higamma.xml").getroot()
    print("      " + ET.tostring(xmlroot.find(".//dynamics"), encoding="unicode"))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

          <dynamics mode="nvt">
            <timestep units="femtosecond"> 1.0 </timestep>
            <thermostat mode="langevin">
              <tau units="femtosecond"> 10 </tau>
            </thermostat>
          </dynamics>
    




.. GENERATED FROM PYTHON SOURCE LINES 344-345

``i-PI`` and ``LAMMPS`` are launched as above ...

.. GENERATED FROM PYTHON SOURCE LINES 345-352

.. code-block:: Python


    ipi_process = None
    if not os.path.exists("simulation_higamma.out"):
        ipi_process = subprocess.Popen(["i-pi", "data/input_higamma.xml"])
        time.sleep(4)  # wait for i-PI to start
        lmp_process = [subprocess.Popen(["lmp", "-in", "data/in.lmp"]) for i in range(1)]








.. GENERATED FROM PYTHON SOURCE LINES 353-355

... and you should probably wait until they're done,
it'll take less than a minute.

.. GENERATED FROM PYTHON SOURCE LINES 355-360

.. code-block:: Python


    if ipi_process is not None:
        ipi_process.wait()
        lmp_process[0].wait()








.. GENERATED FROM PYTHON SOURCE LINES 361-368

Analysis of the trajectory
~~~~~~~~~~~~~~~~~~~~~~~~~~

The temperature converges very quickly to the target value
(fluctuations are to be expected, given that as discussed above
the temperature estimator is just the instantaneous kinetic energy,
that is not constant). There is also equipartition between O and H.

.. GENERATED FROM PYTHON SOURCE LINES 368-392

.. code-block:: Python


    output_data, output_desc = ipi.read_output("simulation_higamma.out")
    traj_data = ipi.read_trajectory("simulation_higamma.pos_0.xyz")

    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.plot(
        output_data["time"],
        output_data["temperature(O)"],
        "r-",
        label="O atoms",
    )
    ax.plot(
        output_data["time"],
        output_data["temperature(H)"],
        "c-",
        label="H atoms",
    )
    ax.plot(output_data["time"], output_data["temperature"], "k-", label="All atoms")
    ax.set_xlabel(r"$t$ / ps")
    ax.set_ylabel(r"$\tilde{T}$ / K")
    ax.legend()
    plt.show()





.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_005.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 393-412

The velocity-velocity correlation function shows how much
this thermostat affects the system dynamics. The high-frequency peaks,
corresponding to stretches and bending, are
greatly broadened, and the :math:`\omega\rightarrow 0`
limit of :math:`\hat{c}_{vv}`, corresponding to the
diffusion coefficient, is reduced by almost a factor of 5.
This last observation highlights that a too-aggressive
thermostat is not only disrupting the dynamics:
it also slows down diffusion through phase space,
making the dynamics less efficient at sampling slow,
collective motions. We shall see further down various
methods to counteract this effect, but in general one should
use a weaker coupling, that improves the sampling of configuration
space even though it slows down the convergence of the
kinetic energy. If you want a thermostat that equilibrates
aggressively the temperature while disturbing less the diffusive
modes, you may try the *fast-forward Langevin* thermostat
`(Hijazi et al., JCP (2018)) <https://doi.org/10.1063/1.5029833>`_
that can be activated with the option ``mode="ffl"``.

.. GENERATED FROM PYTHON SOURCE LINES 412-444

.. code-block:: Python


    # compute the v-v acf
    acf_higamma = compute_acf_xyz(
        "simulation_higamma.vel_0.xyz",
        maximum_lag=600,
        length_zeropadding=2000,
        spectral_windowing="cosine-blackman",
        timestep=1,
        time_units="femtosecond",
        skip=100,
    )

    # and plot
    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.fill_between(
        acf_ref[:1200, 0] * ha2cm1,
        (acf_ref[:1200, 1] - acf_ref[:1200, 2]) * 1e5,
        (acf_ref[:1200, 1] + acf_ref[:1200, 2]) * 1e5,
        color="gray",
        label="reference",
    )
    ax.loglog(
        acf_higamma[3][:1200] * ha2cm1,
        acf_higamma[4][:1200] * 1e5,
        "b-",
        label=r"Langevin, $\tau=10$fs",
    )
    ax.set_xlabel(r"$\omega$ / cm$^{-1}$")
    ax.set_ylabel(r"$\hat{c}_{vv}$ / arb. units")
    ax.legend()
    plt.show()




.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_006.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 445-457

Global thermostats: stochastic velocity rescaling
-------------------------------------------------

An alternative approach to sample the canonical Boltzmann
distribution while introducing fewer disturbances to the system
dynamics is to use a *global* thermostat, i.e. a scheme that
targets the *total* kinetic energy of the system, rather than that
of individual degrees of freedom.
We recommend the "stochastic velocity rescaling" thermostat
`(Bussi, Donadio, Parrinello, JCP (2007)) <https://doi.org/10.1063/1.2408420>`_
that acts by rescaling the total momentum vector, adding a
suitably distributed random noise term.

.. GENERATED FROM PYTHON SOURCE LINES 460-467

Setting up a thermostat in ``i-PI``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Stochastic velocity rescaling is implemented in ``i-PI``
can be selected by setting ``mode="svr"``,  and has a
``tau`` parameter that corresponds to the time scale of the
coupling.

.. GENERATED FROM PYTHON SOURCE LINES 467-471

.. code-block:: Python


    xmlroot = ET.parse("data/input_svr.xml").getroot()
    print("        " + ET.tostring(xmlroot.find(".//thermostat"), encoding="unicode"))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

            <thermostat mode="svr">
              <tau units="femtosecond"> 10 </tau>
            </thermostat>
      




.. GENERATED FROM PYTHON SOURCE LINES 472-473

We run a simulation with the usual set up ...

.. GENERATED FROM PYTHON SOURCE LINES 473-480

.. code-block:: Python


    ipi_process = None
    if not os.path.exists("simulation_svr.out"):
        ipi_process = subprocess.Popen(["i-pi", "data/input_svr.xml"])
        time.sleep(4)  # wait for i-PI to start
        lmp_process = [subprocess.Popen(["lmp", "-in", "data/in.lmp"]) for i in range(1)]








.. GENERATED FROM PYTHON SOURCE LINES 481-482

... and wait for it to finish.

.. GENERATED FROM PYTHON SOURCE LINES 482-487

.. code-block:: Python


    if ipi_process is not None:
        ipi_process.wait()
        lmp_process[0].wait()








.. GENERATED FROM PYTHON SOURCE LINES 488-504

Analysis of the trajectory
~~~~~~~~~~~~~~~~~~~~~~~~~~

The kinetic temperature of the  trajectory equilibrates very
rapidly to the target value. However, it takes a bit longer
(approximately 0.5 ps) to reach equipartition between O and H
atoms. This is an important shortcoming of global thermostats:
since they only target the total kinetic energy, they must rely
on internal energy redistribution to reach equilibrium between
different degrees of freedom.
Liquid water is a very ergodic system, in which all degrees of
freedom are strongly coupled, so this is not a major issue. However
care must be taken when modeling a quasi-harmonic crystal (e.g.
diamond, a metal, or an inorganic crystal), or a molecular system
in which the coupling between molecules is weaker (e.g. methane,
or another apolar compound).

.. GENERATED FROM PYTHON SOURCE LINES 504-528

.. code-block:: Python


    output_data, output_desc = ipi.read_output("simulation_svr.out")
    traj_data = ipi.read_trajectory("simulation_svr.pos_0.xyz")

    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.plot(
        output_data["time"],
        output_data["temperature(O)"],
        "r-",
        label="O atoms",
    )
    ax.plot(
        output_data["time"],
        output_data["temperature(H)"],
        "c-",
        label="H atoms",
    )
    ax.plot(output_data["time"], output_data["temperature"], "k-", label="All atoms")
    ax.set_xlabel(r"$t$ / ps")
    ax.set_ylabel(r"$\tilde{T}$ / K")
    ax.legend()
    plt.show()





.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_007.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 529-540

The velocity-velocity autocorrelation function is
essentially indistinguishable from the reference, computed
with an ensemble of NVE trajectories starting from canonical
samples. In fact, the small discrepancies are mostly due to
incomplete convergence of the averages in the short trajectory.

This highlights the advantages of a global thermostat, that
does not disrupt the natural diffusion in configuration space,
and can often be used to compute dynamical, time-dependent
observables out of a single trajectory -- which is far more
practical than performing a collection of NVE trajectories.

.. GENERATED FROM PYTHON SOURCE LINES 540-570

.. code-block:: Python


    acf_svr = compute_acf_xyz(
        "simulation_svr.vel_0.xyz",
        maximum_lag=600,
        length_zeropadding=2000,
        spectral_windowing="cosine-blackman",
        timestep=1,
        time_units="femtosecond",
        skip=100,
    )

    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.fill_between(
        acf_ref[:1200, 0] * ha2cm1,
        (acf_ref[:1200, 1] - acf_ref[:1200, 2]) * 1e5,
        (acf_ref[:1200, 1] + acf_ref[:1200, 2]) * 1e5,
        color="gray",
        label="reference",
    )
    ax.loglog(
        acf_svr[3][:1200] * ha2cm1,
        acf_svr[4][:1200] * 1e5,
        "b-",
        label=r"SVR, $\tau=10$fs",
    )
    ax.set_xlabel(r"$\omega$ / cm$^{-1}$")
    ax.set_ylabel(r"$\hat{c}_{vv}$ / arb. units")
    ax.legend()
    plt.show()




.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_008.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_008.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 571-603

Generalized Langevin Equation thermostat
----------------------------------------

The issue with a Langevin thermostat is that, for a given coupling
time :math:`\tau`, only molecular motions with a comparable time scale
are sampled efficiently: faster modes are *underdamped*, and slower modes
are *overdamped*, cf. the slowing down of diffusive behavior.

A possible solution to this problem is using a
*Generalized Langevin Equation (GLE)* thermostat. A GLE
thermostat uses a matrix generalization of the Langevin term,
in which the physical momentum is supplemented by a few fictitious
momenta :math:`\mathbf{s}`, i.e.

.. math::

   (\dot{p},\dot{\mathbf{s}}) = -\mathbf{A}_p (p,\mathbf{s})\
   +\mathbf{B}_p (\xi,\boldsymbol{\xi})


Here :math:`\mathbf{A}_p` is the *drift matrix* and  :math:`\mathbf{B}_p`
is a diffusion matrix which, for canonical sampling, is determined by the target
temperature and the drift matrix through a fluctuation-dissipation relation.
The key idea is that :math:`\mathbf{A}_p` provides a lot of flexibility in defining
the behavior of the GLE, that can be tuned to achieve near-optimal sampling
for every degree of freedom (effectively acting as if the coupling constant was
tuned separately for slow and fast molecular motions).
The general idea and the practical implementation are discussed in
`(Ceriotti et al. JCTC (2010)) <http://doi.org/10.1021/ct900563s>`_
which also discusses other applications of the same principle, including
performing simulations with a non-equilibrium *quantum thermostat* that
mimics the quantum the quantum mechanical behavior of light nuclei.

.. GENERATED FROM PYTHON SOURCE LINES 605-620

Setting up a thermostat in ``i-PI``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A GLE thermostat can be activated using ``mode="gle"``.
The drift matrix used here has been generated from the
`GLE4MD website <http://gle4md.org>`_, using parameters that
aim for the most efficient sampling possible with the short
simulation time (2 ps). The `online generator
<https://gle4md.org/index.html?page=matrix&kind=smart&tslow=1&utslow=ps&smrange=6-2&outmode=ipi&aunits=ps>`_
can be tuned to provide the best possible sampling for the system
of interest, the most important parameter being the slowest time scale
that one is interested in sampling (typically a fraction of the total
simulation time). The range of frequencies that is optimized can then
be tuned so as to reach, roughly, the maximum frequency present in the
system.

.. GENERATED FROM PYTHON SOURCE LINES 620-624

.. code-block:: Python


    xmlroot = ET.parse("data/input_gle.xml").getroot()
    print("  " + ET.tostring(xmlroot.find(".//thermostat"), encoding="unicode"))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      <thermostat mode="gle">
        <A shape="(7,7)">
          [   8.191023526179e-4,    8.328506066524e-3,    1.657771834013e-3,    9.736989925341e-4,    2.841803794895e-4,   -3.176846864198e-5,   -2.967010478210e-4, 
      -8.389856546341e-4,    2.405526974742e-2,   -1.507872374848e-2,    2.589784240185e-3,    1.516783633362e-3,   -5.958833418565e-4,    4.198422349789e-4, 
       7.798710586406e-4,    1.507872374848e-2,    8.569039501219e-3,    6.001000899602e-3,    1.062029383877e-3,    1.093939147968e-3,   -2.661575532976e-3, 
      -9.676783161546e-4,   -2.589784240185e-3,   -6.001000899602e-3,    2.680459336535e-5,   -5.214694469742e-5,    4.231304910751e-4,   -2.104894919743e-5, 
      -2.841997149166e-4,   -1.516783633362e-3,   -1.062029383877e-3,    5.214694469742e-5,    1.433903506353e-9,   -4.241574212449e-5,    7.910178912362e-5, 
       3.333208286893e-5,    5.958833418565e-4,   -1.093939147968e-3,   -4.231304910751e-4,    4.241574212449e-5,    2.385554468441e-8,   -3.139255482869e-5, 
       2.967533789056e-4,   -4.198422349789e-4,    2.661575532976e-3,    2.104894919743e-5,   -7.910178912362e-5,    3.139255482869e-5,   2.432567259684e-11
         ]
        </A>
      </thermostat>        
      




.. GENERATED FROM PYTHON SOURCE LINES 625-626

We launch ``i-PI`` as usual ...

.. GENERATED FROM PYTHON SOURCE LINES 626-633

.. code-block:: Python


    ipi_process = None
    if not os.path.exists("simulation_gle.out"):
        ipi_process = subprocess.Popen(["i-pi", "data/input_gle.xml"])
        time.sleep(4)  # wait for i-PI to start
        lmp_process = [subprocess.Popen(["lmp", "-in", "data/in.lmp"]) for i in range(1)]








.. GENERATED FROM PYTHON SOURCE LINES 634-635

... and wait for simulations to finish.

.. GENERATED FROM PYTHON SOURCE LINES 635-640

.. code-block:: Python


    if ipi_process is not None:
        ipi_process.wait()
        lmp_process[0].wait()








.. GENERATED FROM PYTHON SOURCE LINES 641-649

Analysis of the trajectory
~~~~~~~~~~~~~~~~~~~~~~~~~~

The kinetic temperature equilibrates quickly to the target value.
Since the GLE is a local thermostat, targeting each degree of freedom
separately, equipartition is also reached quickly. Sampling is less
fast than with an aggressive Langevin thermostat, because the GLE targets
each vibrational frequency separately, to minimize the impact on diffusion.

.. GENERATED FROM PYTHON SOURCE LINES 649-672

.. code-block:: Python

    output_data, output_desc = ipi.read_output("simulation_gle.out")
    traj_data = ipi.read_trajectory("simulation_gle.pos_0.xyz")

    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.plot(
        output_data["time"],
        output_data["temperature(O)"],
        "r-",
        label="O atoms",
    )
    ax.plot(
        output_data["time"],
        output_data["temperature(H)"],
        "c-",
        label="H atoms",
    )
    ax.plot(output_data["time"], output_data["temperature"], "k-", label="All atoms")
    ax.set_xlabel(r"$t$ / ps")
    ax.set_ylabel(r"$\tilde{T}$ / K")
    ax.legend()
    plt.show()





.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_009.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_009.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 673-681

:math:`\hat{c}_{vv}` reflects the adaptive behavior of the GLE.
The fast modes are damped aggressively, leading to a large
broadening of the high frequency peaks, but librations and diffusive
modes are much less dampened than in the high-coupling Langevin case.
An optimal-coupling GLE is a safe choice to sample any system, from
molecular liquids to harmonic crystals, although a stochastic velocity
rescaling is preferable if one is interested in preserving the natural
dynamics.

.. GENERATED FROM PYTHON SOURCE LINES 681-711

.. code-block:: Python


    acf_gle = compute_acf_xyz(
        "simulation_gle.vel_0.xyz",
        maximum_lag=600,
        length_zeropadding=2000,
        spectral_windowing="cosine-blackman",
        timestep=1,
        time_units="femtosecond",
        skip=100,
    )

    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.fill_between(
        acf_ref[:1200, 0] * ha2cm1,
        (acf_ref[:1200, 1] - acf_ref[:1200, 2]) * 1e5,
        (acf_ref[:1200, 1] + acf_ref[:1200, 2]) * 1e5,
        color="gray",
        label="reference",
    )
    ax.loglog(
        acf_gle[3][:1200] * ha2cm1,
        acf_gle[4][:1200] * 1e5,
        "b-",
        label=r"GLE",
    )
    ax.set_xlabel(r"$\omega$ / cm$^{-1}$")
    ax.set_ylabel(r"$\hat{c}_{vv}$ / arb. units")
    ax.legend()
    plt.show()




.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_010.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_010.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 712-735

R-L purification
~~~~~~~~~~~~~~~~

What if you also want to extract dynamical information from a GLE
(or Langevin) trajectory? It is actually possible to post-process the
power spectrum, performing a deconvolution based on the amount of
disturbance introduced by the GLE, that can be predicted analytically
in the harmonic limit.
The idea, discussed in `(Rossi et al., JCP (2018))
<http://doi.org/10.1063/1.499053610.1063/1.4990536>`_
is that if :math:`\hat{y}(\omega)` is the "natural" NVE power
spectrum, and :math:`k_{\mathrm{GLE}}(\omega_0, \omega)` is the power
spectrum predicted for a harmonic oscillator of frequency :math:`\omega_0`,
then the spectrum from the GLE dynamics will be approximately

.. math::

   \hat{y}_{\mathrm{GLE}}(\omega) = \int \mathrm{d}\omega'
   k_{\mathrm{GLE}}(\omega', \omega) \hat{y}(\omega')

The kernel can be computed analytically for all frequencies that
are relevant for the power spectrum, based on the GLE parameters
extracted from the input of ``i-PI``.

.. GENERATED FROM PYTHON SOURCE LINES 735-753

.. code-block:: Python


    n_omega = 1200
    Ap, Cp, Dp = get_gle_matrices("data/input_gle.xml")
    gle_kernel = gle_frequency_kernel(acf_gle[3][:n_omega], Ap, Dp)


    lomega = acf_gle[3][:n_omega] * ha2cm1
    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    levels = np.logspace(np.log10(gle_kernel.min()), np.log10(gle_kernel.max()), num=50)
    contour = ax.contourf(lomega, lomega, gle_kernel, norm=mpl.colors.LogNorm())
    ax.set_xscale("log")
    ax.set_yscale("log")
    ax.set_xlabel(r"$\omega_0$ / cm$^{-1}$")
    ax.set_ylabel(r"$\omega$ / cm$^{-1}$")
    ax.set_xlim(10, 5000)
    ax.set_ylim(10, 5000)
    cbar = fig.colorbar(contour, ticks=[1e1, 1e3, 1e5, 1e7])




.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_011.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_011.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

     @system: Initializing system object 
     @simulation: Initializing simulation object 
    @ RANDOM SEED: The seed used in this calculation was 32342
     @init_file: Initializing from file data/water_32.pdb. Dimension: length, units: angstrom, cell_units: automatic
     @init_file: Initializing from file data/water_32.pdb. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/water_32.pdb. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/water_32.pdb. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/water_32.pdb. Dimension: length, units: automatic, cell_units: automatic
     @initializer: Resampling velocities at temperature 300.0 kelvin




.. GENERATED FROM PYTHON SOURCE LINES 754-757

The deconvolution is based on the Iterative Image Space
Reconstruction Algorithm, which preserves the positive-definiteness
of the spectrum

.. GENERATED FROM PYTHON SOURCE LINES 757-762

.. code-block:: Python


    isra_acf, history, errors, laplace = isra_deconvolute(
        acf_gle[3][:n_omega], acf_gle[4][:n_omega], gle_kernel, 64, 4
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    # error, laplacian =   2.003584422711218e-08, 5.5979243432528386e-11
    # error, laplacian =   2.2056065682049772e-08, 1.7376959093763714e-10
    # error, laplacian =   2.3108202455947157e-08, 4.097638626672861e-10
    # error, laplacian =   2.3691949074988034e-08, 7.780596938258321e-10
    # error, laplacian =   2.4035784182128285e-08, 1.2694751596779728e-09
    # error, laplacian =   2.4249396569392062e-08, 1.861351757372963e-09
    # error, laplacian =   2.4389091534014125e-08, 2.5265474789901312e-09
    # error, laplacian =   2.4485088512215447e-08, 3.2391093879531283e-09
    # error, laplacian =   2.455418992814817e-08, 3.976980779160915e-09
    # error, laplacian =   2.460605884936594e-08, 4.722774066397663e-09
    # error, laplacian =   2.464644566618402e-08, 5.463518998846859e-09
    # error, laplacian =   2.4678890226455718e-08, 6.189986589300899e-09
    # error, laplacian =   2.4705643657090066e-08, 6.8959202994722526e-09
    # error, laplacian =   2.4728182632746304e-08, 7.577329137028943e-09
    # error, laplacian =   2.4747505357273377e-08, 8.231898073229493e-09




.. GENERATED FROM PYTHON SOURCE LINES 763-767

Even though the ISRA algorithm is less prone to enhancing noise than
other deconvolution algorithms, successive iterations sharpen the spectrum
but introduce higher and higher levles of noise, particularly on the
low-frequency end of the spectrum so one has to choose when to stop.

.. GENERATED FROM PYTHON SOURCE LINES 767-809

.. code-block:: Python


    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.loglog(
        acf_gle[3][:1200] * ha2cm1,
        acf_gle[4][:1200] * 1e5,
        "b-",
        label=r"GLE",
    )
    ax.loglog(
        acf_gle[3][:1200] * ha2cm1,
        history[0] * 1e5,
        ":",
        color="#4000D0",
        label=r"iter[1]",
    )
    ax.loglog(
        acf_gle[3][:1200] * ha2cm1,
        history[2] * 1e5,
        ":",
        color="#A000A0",
        label=r"iter[9]",
    )
    ax.loglog(
        acf_gle[3][:1200] * ha2cm1,
        history[4] * 1e5,
        ":",
        color="#D00040",
        label=r"iter[17]",
    )
    ax.loglog(
        acf_gle[3][:1200] * ha2cm1,
        history[12] * 1e5,
        ":",
        color="#FF0000",
        label=r"iter[49]",
    )

    ax.set_xlabel(r"$\omega$ / cm$^{-1}$")
    ax.set_ylabel(r"$\hat{c}_{vv}$ / arb. units")
    ax.legend()
    plt.show()




.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_012.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_012.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 810-815

Especially in the high-frequency region, the deconvolution
algorithm succees in recovering the underlying NVE dynamics,
which can be useful whenever one wants to optimize statistical
efficiency while still being able to estimate dynamical
properties.

.. GENERATED FROM PYTHON SOURCE LINES 815-842

.. code-block:: Python


    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.fill_between(
        acf_ref[:1200, 0] * ha2cm1,
        (acf_ref[:1200, 1] - acf_ref[:1200, 2]) * 1e5,
        (acf_ref[:1200, 1] + acf_ref[:1200, 2]) * 1e5,
        color="gray",
        label="reference",
    )
    ax.loglog(
        acf_gle[3][:1200] * ha2cm1,
        acf_gle[4][:1200] * 1e5,
        "b-",
        label=r"GLE",
    )
    ax.loglog(
        acf_gle[3][:1200] * ha2cm1,
        history[2] * 1e5,
        "r-",
        label=r"GLE$\rightarrow$ NVE (iter[5])",
    )
    ax.set_xlabel(r"$\omega$ / cm$^{-1}$")
    ax.set_ylabel(r"$\hat{c}_{vv}$ / arb. units")
    ax.legend()
    plt.show()





.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_013.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_013.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 843-864

Running with LAMMPS
~~~~~~~~~~~~~~~~~~~

GLE thermostats (as well as conventional Langevin, and
stochastic velocity rescaling) are also implemented natively
in ``LAMMPS``.

An example of ``LAMMPS`` input containing a GLE thermostat can
be found in ``data/gle.lmp``. See also the
`documentation of the fix gle command
<https://docs.lammps.org/fix_gle.html>`_

.. code-block:: text

  fix 1 all gle 6 300 300 31415 data/smart.A

The drift matrix can be obtained from the same website, simply
asking to output the matrix in raw format, choosing units consistent
with the ``LAMMPS`` settings,  e.g. for this `optimal sampling setup
<https://gle4md.org/index.html?page=matrix&kind=smart&tslow=1&utslow=ps&smrange=6-2&outmode=raw&aunits=fs>`_


.. GENERATED FROM PYTHON SOURCE LINES 866-873

We can run ``LAMMPS`` from the command line

.. code-block:: bash

   lmp -in data/gle.lmp &

or from Python

.. GENERATED FROM PYTHON SOURCE LINES 873-878

.. code-block:: Python


    lmp_process = None
    if not os.path.exists("lammps_out.dat"):
        lmp_process = subprocess.Popen(["lmp", "-in", "data/gle.lmp"])








.. GENERATED FROM PYTHON SOURCE LINES 879-881

... and wait


.. GENERATED FROM PYTHON SOURCE LINES 881-885

.. code-block:: Python


    if lmp_process is not None:
        lmp_process.wait()








.. GENERATED FROM PYTHON SOURCE LINES 886-890

The simulation is much faster (for such a small system and
cheap potential the overhead of ``i-PI``'s client-server mechanism
is substantial) and leads to similar results for the kinetic temperature


.. GENERATED FROM PYTHON SOURCE LINES 890-904

.. code-block:: Python


    traj_data = np.loadtxt("lammps_out.dat")

    fig, ax = plt.subplots(1, 1, figsize=(4, 3), constrained_layout=True)
    ax.plot(
        traj_data[:, 0] * 1e-3,
        traj_data[:, 1],
        "k-",
        label="All atoms",
    )
    ax.set_xlabel(r"$t$ / ps")
    ax.set_ylabel(r"$\tilde{T}$ / K")
    ax.legend()
    plt.show()



.. image-sg:: /examples/thermostats/images/sphx_glr_thermostats_014.png
   :alt: thermostats
   :srcset: /examples/thermostats/images/sphx_glr_thermostats_014.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 15.665 seconds)


.. _sphx_glr_download_examples_thermostats_thermostats.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: thermostats.ipynb <thermostats.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: thermostats.py <thermostats.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

        :download:`Download recipe: thermostats.zip <thermostats.zip>`
    

.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
