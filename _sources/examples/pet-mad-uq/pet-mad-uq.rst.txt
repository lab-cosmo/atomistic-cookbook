
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/pet-mad-uq/pet-mad-uq.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_pet-mad-uq_pet-mad-uq.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_pet-mad-uq_pet-mad-uq.py:


Uncertainty Quantification with PET-MAD
=======================================

:Authors: Johannes Spies `@johannes-spies <https://github.com/johannes-spies>`_

This recipe demonstrates three ways of computing errors on the outputs of
ML potential-driven simulations, using as an example the PET-MAD model and its
built-in uncertainty quantification (UQ) capabilities.

In particular, it demonstrates:

1. Estimating uncertainties for single-point calculations on a
   full validation dataset.
2. Computing energies in simple functions of energy predictions,
   namely the value of vacancy formation energies
3. Propagating errors from energy predictions to thermodynamic averages
   computed over a constant-temperature MD simulation.


For more information on PET-MAD, have a look at
`Mazitov et al., 2025. <https://arxiv.org/abs/2503.14118>`_
The LLPR uncertainties are introduced in `Bigi et al., 2024.
<https://arxiv.org/abs/2403.02251>`_ For more
information on dataset calibration and error propagation, see
`Imabalzano et al., 2021. <https://arxiv.org/abs/2011.08828>`_

Optional: Adding UQ to a Model
------------------------------

Models compatible with `metatomic <https://metatensor.github.io/metatomic/>`_ can be
equipped with UQ capabilities through the
`LLPRUncertaintyModel` wrapper included with
`metatrain <https://metatensor.github.io/metatrain/>`_. For running this recipe, you can
use a prebuilt model (the example itself downloads a model from Hugging Face).
For adding UQ support to an existing model, have a look at
the following scaffold. For more information on loading a dataset with the
infrastructure, have a look at
`this section <https://metatensor.github.io/metatrain/latest/dev-docs/utils/data>`_
of the documentation. The pseudocode below also shows how to create an ensemble model
from the last-layer parameters of a model.

.. code-block:: python

    from metatrain.utils.llpr import LLPRUncertaintyModel
    from metatomic.torch import AtomisticModel, ModelMetadata

    # You need to provide a model and datasets (wrapped in PyTorch dataloaders).
    model = ...
    dataloaders = {"train": ..., "val": ...}

    # Wrap the model in a module capable of estimating uncertainties, estimate the
    # inverse covariance on the training set, and calibrate the model on the validation
    # set.
    llpr_model = LLPRUncertaintyModel(model)
    llpr_model.compute_covariance(dataloaders["train"])
    llpr_model.compute_inverse_covariance(regularizer=1e-4)
    llpr_model.calibrate(dataloaders["val"])

    # In the next step, we show how to enable ensembles in PET-MAD. For that, it is
    # necessary to extract the last-layer parameters of the model. The ensemble
    # generation expects the parameters in a flat-vector format.
    last_layer_parameters = ...

    # Generate an ensemble with 128 members to compare ensemble uncertainties to LLPR
    # scores.
    llpr_model.generate_ensemble({"energy": last_layer_parameters}, 128)

    # Save the model to disk using metatomic.
    exported_model = AtomisticModel(
        llpr_model.eval(),
        ModelMetadata(),
        llpr_model.capabilities,
    )
    exported_model.save("models/model-with-llpr.pt")

Getting Started
---------------

At the bottom of the page, you'll find a ZIP file containing the whole example. Note
that it comes with an `environment.yml` file specifying all dependencies required
to execute the script.

.. GENERATED FROM PYTHON SOURCE LINES 86-107

.. code-block:: Python

    import os
    import subprocess
    from urllib.request import urlretrieve

    import ase.cell
    import ase.ga.utilities
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import torch
    from ase import Atoms
    from ase.filters import FrechetCellFilter
    from ase.io.cif import read_cif
    from ase.optimize.bfgs import BFGS
    from ipi.utils.scripting import InteractiveSimulation
    from metatomic.torch import ModelOutput
    from metatomic.torch.ase_calculator import MetatomicCalculator
    from metatrain.utils.data import Dataset, read_systems, read_targets
    from metatrain.utils.data.system_to_ase import system_to_ase









.. GENERATED FROM PYTHON SOURCE LINES 108-115

Model Loading
-------------
All examples require a PET-MAD model with ensemble and LLPR prediction. The
following
code loads a pre-trained model using the ASE-compatible calculator wrapper. Using the
calculator instead of calling the model directly conveniently hides computing
neighbor lists in the calculator.

.. GENERATED FROM PYTHON SOURCE LINES 115-125

.. code-block:: Python

    if not os.path.exists("models/pet-mad-latest-llpr.pt"):
        os.makedirs("models", exist_ok=True)
        urlretrieve(
            "https://huggingface.co/jospies/pet-mad-llpr/resolve/main/"
            "pet-mad-latest-llpr.pt?download=true",
            "models/pet-mad-latest-llpr.pt",
        )

    calculator = MetatomicCalculator("models/pet-mad-latest-llpr.pt", device="cpu")








.. GENERATED FROM PYTHON SOURCE LINES 126-136

Uncertainties on a Dataset
----------------------------------------------
This first example shows how to use PET-MAD to estimate uncertainties on a reference
dataset. We use a reduced version (because of limited compute power in the CI runner)
of the MAD validation set.

For this, we first download the correspond MAD validation dataset record from
Materials Cloud. Then, we prepare the dataset and pass it through the model. In the
final step, we visualize the predicted uncertainties and compare them to a
ground truth method.

.. GENERATED FROM PYTHON SOURCE LINES 136-169

.. code-block:: Python


    if not os.path.exists("data/mad-val-100.xyz"):
        os.makedirs("data", exist_ok=True)
        urlretrieve(
            "https://huggingface.co/jospies/pet-mad-llpr/resolve/main/mad-val-100.xyz"
            "?download=true",
            "data/mad-val-100.xyz",
        )

    # Read the dataset's structures.
    systems = read_systems("data/mad-val-100.xyz")

    # Read the dataset's targets.
    target_config = {
        "energy": {
            "quantity": "energy",
            "read_from": "data/mad-val-100.xyz",
            "reader": "ase",
            "key": "energy",
            "unit": "kcal/mol",
            "type": "scalar",
            "per_atom": False,
            "num_subtargets": 1,
            "forces": False,
            "stress": False,
            "virial": False,
        },
    }
    targets, infos = read_targets(target_config)  # type: ignore

    # Wrap in a `metatrain` compatible way.
    dataset = Dataset.from_dict({"system": systems, **targets})





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/work/atomistic-cookbook/atomistic-cookbook/.nox/pet-mad-uq/lib/python3.12/site-packages/metatrain/utils/data/readers/ase.py:62: UserWarning: A conversion to `System` was requested for an `ase.Atoms` object with one or more non-zero cell vectors but where the corresponding boundary conditions are set to `False`. The corresponding cell vectors will be set to zero.
      systems = systems_to_torch(ase_atoms, dtype=torch.float64)




.. GENERATED FROM PYTHON SOURCE LINES 170-172

After preparation, the dataset can be passed through the model using the calculator
to obtain energy predictions and LLPR scores.

.. GENERATED FROM PYTHON SOURCE LINES 172-186

.. code-block:: Python


    # Convert the systems to an ASE-native `Atoms` object
    systems = [system_to_ase(sample["system"]) for sample in dataset]
    outputs = {
        # Request the uncertainty in the atomic energy predictions
        "energy": ModelOutput(),  # (Needed to request the uncertainties)
        "energy_uncertainty": ModelOutput(),
    }
    results = calculator.run_model(systems, outputs)

    # Extract the requested results
    predicted_energies = results["energy"][0].values.squeeze()
    predicted_uncertainties = results["energy_uncertainty"][0].values.squeeze()








.. GENERATED FROM PYTHON SOURCE LINES 187-189

Compute the true prediction error by comparing the predicted energy to the reference
value from dataset.

.. GENERATED FROM PYTHON SOURCE LINES 189-198

.. code-block:: Python


    # Reference values from dataset.
    ground_truth_energies = torch.stack(
        [sample["energy"][0].values.squeeze() for sample in dataset]
    )

    # Compute squared distance between predicted energy and reference value.
    empirical_errors = torch.abs(predicted_energies - ground_truth_energies)








.. GENERATED FROM PYTHON SOURCE LINES 199-206

After gathering predicted uncertainties and computing ground truth error metrics, we
can compare them to each other. Similar to figure S4 of the PET-MAD paper, we present
the data in using a parity plot. For more information about interpreting this type of
plot, see Appendix F.7 of `Bigi et al., 2024 <https://arxiv.org/abs/2403.02251>`_.
Note that both the x- and the y-axis use a logarithmic scale, which is more suitable
for inspecting uncertainty values. Because we are using a heavily reduced dataset
(only 100 structures) from the MAD validation set, the parity plot looks very sparse.

.. GENERATED FROM PYTHON SOURCE LINES 206-231

.. code-block:: Python


    # Hard-code the zoomed in region of the plot and iso-lines.
    quantile_lines = [0.00916, 0.10256, 0.4309805, 1.71796, 2.5348, 3.44388]
    min_val, max_val = 2.5e-2, 2.5

    # Create the parity plot.
    plt.figure(figsize=(4, 4))
    plt.grid()
    plt.gca().set(
        title="Parity of Uncertainties",
        ylabel="Errors",
        xlabel="Uncertainties",
    )
    plt.loglog()

    # Plot iso lines.
    plt.plot([min_val, max_val], [min_val, max_val], ls="--", c="k")
    for factor in quantile_lines:
        plt.plot([min_val, max_val], [factor * min_val, factor * max_val], "k:", lw=0.75)

    # Add actual samples.
    plt.scatter(predicted_uncertainties, empirical_errors)

    plt.tight_layout()




.. image-sg:: /examples/pet-mad-uq/images/sphx_glr_pet-mad-uq_001.png
   :alt: Parity of Uncertainties
   :srcset: /examples/pet-mad-uq/images/sphx_glr_pet-mad-uq_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 232-247

Uncertainties in Vacancy Formation Energies
-------------------------------------------
One can use ensemble uncertainty quantification to estimate the error in predicting
`vacancy formation <https://en.wikipedia.org/wiki/Vacancy_defect>`_
energies, which we show in this example.

In this part, we use an aluminum crystal as an example system. The structure file can
be downloaded from
`Material Project <https://legacy.materialsproject.org/materials/mp-134/>`_
as a `.cif` file. We've included such a file with the recipe.

The following code loads the structure, computes the energy before creating a defect,
creates a defect, runs a structural optimization, and computes the energy after the
optimization. The energy difference can be used to estimate the vacancy formation
energy.

.. GENERATED FROM PYTHON SOURCE LINES 247-256

.. code-block:: Python


    # Load the crystal from the Materials Project and create a supercell (not strictly
    # necessary).
    crystal_structure = "data/Al_mp-134_conventional_standard.cif"
    atoms: Atoms = read_cif(crystal_structure)  # type: ignore
    supercell = atoms * 2
    supercell.calc = calculator
    N = len(supercell)  # store the number of atoms








.. GENERATED FROM PYTHON SOURCE LINES 257-260

We now compute the vacancy formation energy by keeping track of the ensemble energies
at different stages. Note that calling `.get_potential_energy()` on an `Atoms` object
triggers computing the ensemble values.

.. GENERATED FROM PYTHON SOURCE LINES 260-284

.. code-block:: Python


    # Get ensemble energy before creating the vacancy
    outputs = ["energy", "energy_uncertainty", "energy_ensemble"]
    outputs = {o: ModelOutput() for o in outputs}
    results = calculator.run_model(supercell, outputs)
    bulk = results["energy_ensemble"][0].values

    # Remove an atom (last atom in this case) to create a vacancy
    i = -1
    supercell.pop(i)

    # Get ensemble energy right after creating the vacancy
    results = calculator.run_model(supercell, outputs)
    right_after_vacancy = results["energy_ensemble"][0].values

    # Run structural optimization optimizing both positions and cell layout.
    ecf = FrechetCellFilter(supercell)
    bfgs = BFGS(ecf)  # type: ignore
    bfgs.run()

    # get ensembele energy after optimization
    results = calculator.run_model(supercell, outputs)
    vacancy = results["energy_ensemble"][0].values





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

          Step     Time          Energy          fmax
    BFGS:    0 12:16:07     -122.585747        0.130144
    BFGS:    1 12:16:07     -122.589012        0.122949
    BFGS:    2 12:16:07     -122.620888        0.096033
    BFGS:    3 12:16:08     -122.621590        0.095035
    BFGS:    4 12:16:08     -122.629791        0.078909
    BFGS:    5 12:16:08     -122.633263        0.069312
    BFGS:    6 12:16:08     -122.635338        0.062530
    BFGS:    7 12:16:08     -122.636513        0.060593
    BFGS:    8 12:16:08     -122.639427        0.065046
    BFGS:    9 12:16:08     -122.644005        0.058952
    BFGS:   10 12:16:09     -122.649384        0.035778




.. GENERATED FROM PYTHON SOURCE LINES 285-286

Compute vacancy formation energy for each ensemble member.

.. GENERATED FROM PYTHON SOURCE LINES 286-289

.. code-block:: Python


    vacancy_formation = vacancy - (N - 1) / N * bulk








.. GENERATED FROM PYTHON SOURCE LINES 290-291

Put all ensemble energies in a dataframe and compute the desired statistics.

.. GENERATED FROM PYTHON SOURCE LINES 291-311

.. code-block:: Python


    # This dataframe contains each stage's energies in a single column.
    named_stages = [
        ("Before creating vacancy", bulk),
        ("Right after creating vacancy", right_after_vacancy),
        ("Energy of optimized vacancy", vacancy),
        ("Vacancy formation energy", vacancy_formation),
    ]
    df = pd.DataFrame.from_dict(
        {
            # Convert the PyTorch tensors to flat NumPy vectors
            k: v.detach().numpy().squeeze()
            for k, v in named_stages
        }
    )

    # Compute statistics (mean, variance, and standard deviation) on the ensemble energies.
    df = pd.DataFrame(dict(mean=df.mean(), var=df.var(), std=df.std()))
    df






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>mean</th>
          <th>var</th>
          <th>std</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>Before creating vacancy</th>
          <td>-127.312576</td>
          <td>1.347788</td>
          <td>1.160943</td>
        </tr>
        <tr>
          <th>Right after creating vacancy</th>
          <td>-122.585754</td>
          <td>1.116813</td>
          <td>1.056794</td>
        </tr>
        <tr>
          <th>Energy of optimized vacancy</th>
          <td>-122.649384</td>
          <td>1.129493</td>
          <td>1.062776</td>
        </tr>
        <tr>
          <th>Vacancy formation energy</th>
          <td>0.684682</td>
          <td>0.011522</td>
          <td>0.107340</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 312-329

Uncertainty Propagation with MD
-------------------------------

This example shows how to use i-PI to propagate error estimates from an ensemble to
output observables. In this example, we use a box with period boundary conditions
housing 32 water molecules. As an observable, we inspect the `Radial Distribution
Function (RDF) <https://en.wikipedia.org/wiki/Radial_distribution_function>`_ between
hydrogen-hydrogen and oxygen-oxygen bonds.

First, we run a simulation with i-PI generating a trajectory and logging other
metrics. The trajectory and committee energies can be used in a subsequent
postprocessing step to obtain RDFs using ASE. These can be re-weighted to propagate
errors from the committee uncertainties to the observed RDFs.

Note also that we set a `uncertainty_threshold` option in the driver. When running
from the command line, this will output a warning every time one of the atomic energy
is estimated to have an uncertainty above that threshold (in eV/atom).

.. GENERATED FROM PYTHON SOURCE LINES 330-340

.. code-block:: Python


    # Load configuration and run simulation.
    with open("data/h2o-32.xml") as f:
        xml_input = f.read()

    # prints the relevant sections of the input file
    print(xml_input[:883][-334:])

    sim = InteractiveSimulation(xml_input)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      <ffdirect name='nocons' pbc="true">
        <pes>metatomic</pes>
        <parameters>
            { template:data/h2o-32.xyz,model:models/pet-mad-latest-llpr.pt,device:cpu,
              non_conservative:False,energy_ensemble:True,
              check_consistency:False,
              uncertainty_threshold:7.0e-2
            }
        </parameters>
      </ffdirect>

     @system: Initializing system object 
     @simulation: Initializing simulation object 
    @ RANDOM SEED: The seed used in this calculation was 23658
     @init_file: Initializing from file data/h2o-32.xyz. Dimension: length, units: angstrom, cell_units: automatic
     @init_file: Initializing from file data/h2o-32.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/h2o-32.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/h2o-32.xyz. Dimension: length, units: automatic, cell_units: automatic
     @init_file: Initializing from file data/h2o-32.xyz. Dimension: length, units: automatic, cell_units: automatic
     @initializer: Resampling velocities at temperature 300.0 kelvin
     --- begin input file content ---

      <simulation verbosity='medium'>
        <output prefix='h2o-32'>
          <properties filename='out' stride='10'>[ time{picosecond}, temperature{kelvin}, kinetic_md ]</properties>
          <trajectory filename='pos' format='xyz' stride='10' cell_units='angstrom'>positions{angstrom}</trajectory>
          <trajectory filename='committee_pot' stride='10' extra_type='committee_pot'>extras</trajectory>
          <trajectory filename='atomic_error' stride='10' extra_type='energy_uncertainty'>extras</trajectory>
        </output>
        <prng>
          <seed>23658</seed>
        </prng>
        <ffdirect name='nocons' pbc='true'>
          <pes>metatomic</pes>
          <parameters>{ template:data/h2o-32.xyz,model:models/pet-mad-latest-llpr.pt,device:cpu,
              non_conservative:False,energy_ensemble:True,
              check_consistency:False,
              uncertainty_threshold:7.0e-2
            }</parameters>
        </ffdirect>
        <system>
          <initialize nbeads='1'>
            <file mode='xyz' units='angstrom'>data/h2o-32.xyz</file>
            <velocities mode='thermal' units='kelvin'>300</velocities>
          </initialize>
          <forces>
            <force forcefield='nocons'>
            </force>
          </forces>
          <ensemble>
            <temperature units='kelvin'>300</temperature>
          </ensemble>
          <motion mode='dynamics'>
            <fixcom>True</fixcom>
            <dynamics mode='nvt'>
              <timestep units='femtosecond'>0.5</timestep>
              <thermostat mode='langevin'>
                <tau units='femtosecond'>50</tau>
              </thermostat>
            </dynamics>
          </motion>
        </system>
      </simulation>
     ---  end input file content  ---
     @system.bind: Binding the forces 




.. GENERATED FROM PYTHON SOURCE LINES 341-342

Run the simulation.

.. GENERATED FROM PYTHON SOURCE LINES 342-347

.. code-block:: Python


    # NB: To get better estimates, set this to a higher number (perhaps 10000) to
    # run the simulation for a longer time.
    sim.run(100)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

     @simulation.run: Average timings at MD step       0. t/step: 1.11586e+00
     !W! the estimated atomic energy uncertainty 0.0701 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0700 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0701 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0701 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0701 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0700 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0701 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0703 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0704 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0705 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0705 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0704 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0704 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0703 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0702 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0702 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0702 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0701 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0700 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0700 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0702 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0704 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0706 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0707 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0709 eV/atom exceeds the selected threshold of 0.0700 eV/atom
     !W! the estimated atomic energy uncertainty 0.0710 eV/atom exceeds the selected threshold of 0.0700 eV/atom




.. GENERATED FROM PYTHON SOURCE LINES 348-349

Load the trajectories and compute the per-frame RDFs

.. GENERATED FROM PYTHON SOURCE LINES 349-377

.. code-block:: Python

    frames: list[Atoms] = ase.io.read("h2o-32.pos_0.xyz", ":")  # type: ignore

    # Our simulation should only include water molecules. (types: hydrogen=1, oxygen=8)
    assert set(frames[0].numbers.tolist()) == set([1, 8])

    # Compute the RDF of each frame (for H-H and for O-O)
    num_bins = 100
    rdfs_hh = []
    rdfs_oo = []
    xs = None
    for atoms in frames:
        atoms.pbc = True
        atoms.cell = ase.cell.Cell(9.86592 * np.eye(3))

        # Compute H-H distances
        bins, xs = ase.ga.utilities.get_rdf(  # type: ignore
            atoms, 4.5, num_bins, elements=[1, 1]
        )
        rdfs_hh.append(bins)

        # Compute O-O distances
        bins, xs = ase.ga.utilities.get_rdf(  # type: ignore
            atoms, 4.5, num_bins, elements=[8, 8]
        )
        rdfs_oo.append(bins)
    rdfs_hh = np.stack(rdfs_hh, axis=0)
    rdfs_oo = np.stack(rdfs_oo, axis=0)








.. GENERATED FROM PYTHON SOURCE LINES 378-379

Run the i-PI re-weighting utility as a post-processing step.

.. GENERATED FROM PYTHON SOURCE LINES 379-397

.. code-block:: Python


    # Save RDFs such that they can be read from i-PI.
    np.savetxt("h2o-32_rdfs_h-h.txt", rdfs_hh)
    np.savetxt("h2o-32_rdfs_o-o.txt", rdfs_oo)

    # Run the re-weighting tool from i-PI for H-H and O-O
    for ty in ["h-h", "o-o"]:
        infile = f"h2o-32_rdfs_{ty}.txt"
        outfile = f"h2o-32_rdfs_{ty}_reweighted.txt"
        cmd = (
            f"i-pi-committee-reweight h2o-32.committee_pot_0 {infile} --input"
            " data/h2o-32.xml"
        )
        print("Executing command:", "\t" + cmd, sep="\n")
        cmd = cmd.split()
        with open(outfile, "w") as out:
            process = subprocess.run(cmd, stdout=out)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Executing command:
            i-pi-committee-reweight h2o-32.committee_pot_0 h2o-32_rdfs_h-h.txt --input data/h2o-32.xml
    Executing command:
            i-pi-committee-reweight h2o-32.committee_pot_0 h2o-32_rdfs_o-o.txt --input data/h2o-32.xml




.. GENERATED FROM PYTHON SOURCE LINES 398-400

Load and display the RDFs after re-weighting. Note that the results might not noisy
due to the small number of MD steps.

.. GENERATED FROM PYTHON SOURCE LINES 400-428

.. code-block:: Python


    # Load the reweighted RDFs.
    rdfs_hh_reweighted = np.loadtxt("h2o-32_rdfs_h-h_reweighted.txt")
    rdfs_oo_reweighted = np.loadtxt("h2o-32_rdfs_o-o_reweighted.txt")

    # Extract columns.
    rdfs_hh_reweighted_mu = rdfs_hh_reweighted[:, 0]
    rdfs_hh_reweighted_err = rdfs_hh_reweighted[:, 1]
    rdfs_hh_reweighted_committees = rdfs_hh_reweighted[:, 2:]

    rdfs_oo_reweighted_mu = rdfs_oo_reweighted[:, 0]
    rdfs_oo_reweighted_err = rdfs_oo_reweighted[:, 1]
    rdfs_oo_reweighted_committees = rdfs_oo_reweighted[:, 2:]

    # Display results.
    fig, axs = plt.subplots(figsize=(6, 3), sharey=True, ncols=2)
    for title, ax, mus, errs, xlim in [
        ("H-H", axs[0], rdfs_hh_reweighted_mu, rdfs_hh_reweighted_err, (0.0, 4.5)),
        ("O-O", axs[1], rdfs_oo_reweighted_mu, rdfs_oo_reweighted_err, (2.0, 4.5)),
    ]:
        ylabel = "RDF" if title == "H-H" else None
        ax.set(title=title, xlabel="Distance", ylabel=ylabel, xlim=xlim, ylim=(-1, 3.0))
        ax.grid()
        ax.plot(xs, mus, label="Mean", lw=2)
        z95 = 1.96
        rdfs_ci95 = (mus - z95 * errs, mus + z95 * errs)
        ax.fill_between(xs, *rdfs_ci95, alpha=0.4, label="CI95")
        ax.legend()



.. image-sg:: /examples/pet-mad-uq/images/sphx_glr_pet-mad-uq_002.png
   :alt: H-H, O-O
   :srcset: /examples/pet-mad-uq/images/sphx_glr_pet-mad-uq_002.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 5.484 seconds)


.. _sphx_glr_download_examples_pet-mad-uq_pet-mad-uq.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: pet-mad-uq.ipynb <pet-mad-uq.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: pet-mad-uq.py <pet-mad-uq.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

        :download:`Download recipe: pet-mad-uq.zip <pet-mad-uq.zip>`
    

.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
